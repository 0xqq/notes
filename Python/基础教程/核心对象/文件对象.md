----



----

# 简单介绍

> file对象是Python核心对象,可以通过内置open(name[, mode[, buffering]])函数创建

# 破冰例子

```python
#! -*- coding: utf-8 -*-

f = open('/etc/passwd')
print f.read()
```

# 文件对象

## 创建方式

````python
# name表示文件名,支持相对路径或绝对路径,需要注意的是WIN下面为\但Python会以转义符解析,所以需要写成\\形式
# mode表示文件读写模式,如下列表
# buffering表示缓冲方式,0表示写到文件的内容立即写入硬盘,1表示写入\n换行时再写入硬盘,小于0表示使用系统默认缓冲大小,大于1时表示使用其作为缓冲大小
open(name[, mode[, buffering]]) -> file object 
````

### 读写模式

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| r    | 只读模式,目标文件必须存在,打开写入时抛IOError异常,           |
| w    | 只写模式,目标文件无需存在,打开读取时抛IOError异常,写入时目标文件存在则先清空再写入,反正新建并写入,默认指针起点都为0,同Unix命令> |
| a    | 追加模式,目标文件无需存在,打开读取时抛IOError异常,写入时目标文件存在则追加,反之新建并写入,默认指针起点为文件内容长度,同Unix命令>> |
| r+   | 读写模式,目标文件必须存在,写入时目标文件存在则从上次指针位置覆盖,默认指针起点都为0 |
| w+   | 读写模式,目标文件无需存在,写入时目标文件存在则从先清空再写入,反之新建并写入,默认指针起点都为0,同Unix命令> |

* 如上5种模式都可以与t(默认文本模式)或b(二进制模式)结合,如rb,Unix平台两种模式无区别,Wins平台文本模式读取会将\r\n转换为\n,所以Unix文件在Wins上打开会整行显示,写入会将\n转换为\r\n,所以Wins文件在Unix上打开会显示^M控制符

## 属性方法

|                                   |                                                              |
| --------------------------------- | ------------------------------------------------------------ |
| f.closed                          | 只读属性,判断fd.close()是否调用过来表示文件句柄是否关闭      |
| f.encoding                        | 只读属性,文件编码格式                                        |
| f.mode                            | 只读属性,文件打开模式                                        |
| f.name                            | 只读属性,文件名称                                            |
| f.close()                         | 关闭文件句柄,可显式调用,也可通过with上下文管理器自动关闭     |
| f.flush()                         | 将缓冲区数据立即写入硬盘                                     |
| f.isatty()                        | 文件句柄是否为一个交互终端                                   |
| f.fileno()                        | 整数,文件描述符                                              |
| f.read([size])                    | size<0表示读取整个文件,size>0表示size字节                    |
| f.readlines([size])               | size>=0表示读取size字节作为整行返回,size<0表示读取遇到\n时作为整行返回 |
| f.next()                          | file对象可迭代,每次迭代返回其中的一行,直至抛出StopIteration异常 |
| f.seek(offset[, whence])          | whence=0表示当前指针从文件开头偏移offset字节,whence=1表示当前指针从文件当前位置偏移offset字节,whence=2表示当前指针从文件末尾偏移offset位置 |
| f.tell()                          | 当前指针距离文件开头的字节数                                 |
| f.truncate([size])                | size>0表示保留size字节,如果不够以0填充,不提供size则保留整个文件内容 |
| f.write(str)                      | 以对应模式将str写入文件                                      |
| f.writelines(sequence_of_strings) | 以对应模式将一组数据写入文件                                 |

# 实战练习

* 如何快速创建一个100G的文件 ?
  * 思考
    * 与dd if=/dev/zero  of=example bs=1024m count=100的区别?

```python

```

* 如何实现Unix系统tail -f的功能 ?
  * 思考
    * 如果读取的是一个100G的超大文件哪?

```python

```





